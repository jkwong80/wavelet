import os, sys
import h5py
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt

lineStyles = ['-', '--', '-.', ':']
markerTypes = ['.', '*', 'o', 'd', 'h', 'p', 's', 'v', 'x']
plotColors = ['k', 'r', 'g', 'b', 'm', 'y', 'c'] * 10


file_directory = os.path.dirname(os.path.realpath(__file__))
print(os.path.realpath(__file__))
print(file_directory)
sys.path.append(os.path.join(file_directory, "../common"))
sys.path.append(os.path.join(file_directory, ".."))

# import wavelet_core.bins

import training_dataset_processor.training_dataset_processor
import detection_algorithms.isotope_id.isotope_id

paths = training_dataset_processor.training_dataset_processor.GetInjectionResourcePaths()

paths['real_data'] = os.path.join(paths['real_data_root'], 'old')

# In order to create an instance of the isotope id object, you need these two input files
# 1) model parameters generated by create_isotope_id_resources.pyd
# 2) the keras neural network file created by train_classifiers_grid.py
parameters_file = os.path.join(paths['models_root'], '9', 'model_parameters.h5')
neural_network_file = os.path.join(paths['models_root'], '9', 'model__kS_02__kB_16__gap_04__mask_filtered_features_2__speed_00_25__nn_3layer__00_02.h5')

# create and instance of the classifier
id = detection_algorithms.isotope_id.isotope_id.isotope_id(parameters_file, neural_network_file)

# Some old honeybadger data
input_filename = 'CalibratedLog_2016-11-02T11-19-57Z_Background.h5'

input_fullfilename = os.path.join(paths['real_data'], input_filename)

# Read in the spectra and time arrays
detector_name = '88'
time_name = 'time'
with h5py.File(input_fullfilename, 'r') as dat:
    print(dat.keys())

    if '88' in dat:
        spectra = dat[detector_name]['rebinned_spectra'].value
        t = dat[detector_name]['timestamp_us'].value
    elif 'sensor_150_degree' in dat:
        spectra = dat[detector_name]['spectrum'].value
        t = dat[detector_name]['time'].value

    # 'CalibratedLog_2016-11-02T11-19-57Z_Background.h5'
    elif 'spectra' in dat:
        spectra = dat['spectra'][1,:,:]
        t = dat['time_array'].value

# Initialize arrays for storing probability and snr values
snr_array = np.zeros((spectra.shape[0], id.snr_dimensions))
prob_array = np.zeros((spectra.shape[0], id.prob_dimensions))

# use the classifier to calculate snr and probability values
for acquisition_index in xrange(spectra.shape[0]):

    if acquisition_index % 5000 == 0:
        print('{}/{}'.format(acquisition_index, spectra.shape[0]))
    temp = id.ingest(spectra[acquisition_index,:])
    prob_array[acquisition_index,:] = temp[0]
    snr_array[acquisition_index,:] = temp[1]

# the prediction is just the index of the value with the highest probability
prediction = np.argmax(prob_array, 1)


# Display tally of things found and their fraction
# (Should be mainly background)
counts = np.bincount(prediction)
print('isotope index, name, # acquisitions, fraction')
for i, c in enumerate(counts):
    if c >0:
        print('{}, {}, {}, {}'.format(i, id.isotopes[i], c, float(c)/len(prediction)))


# Create Plots

# Plot of the total counts, probabilties, prediction vs acquisition index (time)

subpploty, subplotx = 5, 1
subplot_index =1

plt.figure(figsize = [28, 30])

plt.subplot(subpploty, subplotx, subplot_index); subplot_index+=1
plt.imshow(spectra.T, aspect = 'auto', interpolation = 'nearest')
# plt.colorbar()
plt.title('Energy Spectrum')
plt.xlabel('Acquisition Index')
plt.ylabel('Energy Index')

plt.subplot(subpploty, subplotx, subplot_index); subplot_index+=1
plt.imshow(snr_array.T, aspect = 'auto', interpolation = 'nearest')
# plt.colorbar()
plt.title('SNR')
plt.xlabel('Acquisition Index')
plt.ylabel('SNR')

plt.subplot(subpploty, subplotx, subplot_index); subplot_index+=1
plt.imshow(prob_array.T, aspect = 'auto', interpolation = 'nearest')
plt.title('Probability of Each Class')
plt.xlabel('Acquisition Index')
plt.ylabel('Class Index')

plt.subplot(subpploty, subplotx, subplot_index); subplot_index+=1
plt.grid()
for i in xrange(prob_array.shape[1]):
    plt.plot(prob_array[:,i], alpha = 0.5, color = plotColors[i % 7], linestyle = lineStyles[i/7],\
             label = '{}) {}'.format(i, id.isotopes[i]))
plt.xlim((0, spectra.shape[0]))
plt.legend(fontsize = 9)
plt.xlabel('Acquisition Index')
plt.ylabel('Probability')
plt.title('Probability of each Class')

plt.subplot(subpploty, subplotx, subplot_index); subplot_index+=1
plt.grid()
plt.plot(np.argmax(prob_array, axis =1), alpha = 0.5, label = 'Class Index')
plt.plot(spectra.sum(1)/max(spectra.sum(1)), label = 'Counts (normalized)')

plt.xlim((0, spectra.shape[0]))
plt.title('Index of Class with Highest Probability')
plt.xlabel('Acquisition Index')
plt.ylabel('Predicted Class Index')
plt.legend()

plt.savefig(os.path.join(paths['plot'], '%s__vs_acquisition.pdf' %(input_filename.replace('.h5', '')  )))
plt.close()


# Plot a specific section in 'CalibratedLog_2016-11-02T11-19-57Z_Background.h5'
# In this section, it looks like there is some glitches, but I think it's actually
# seeing differences in background
acq_bounds_list = [[2420,2430], [2460, 2480], [2540,2550]]
plt.figure()
plt.grid()
for acq_bounds in acq_bounds_list:
    plt.plot(spectra[acq_bounds[0]:acq_bounds[1],:].mean(0), label = '{},{}'.format(acq_bounds[0], acq_bounds[1]))
plt.legend()
plt.xlabel('Energy Bin Index')
plt.ylabel('Count')
plt.yscale('log')
plt.ylim((0.01, 100))

plt.savefig(os.path.join(paths['plot'], '%s__spectra_subset_of_interest.pdf' %(input_filename.replace('.h5', '')  )))
plt.close()



# 2-d plot of spectra of the spectra for each class
# Note, the 2d plot will look strange if there are only 1 or a few acquisitions with this

for i, c in enumerate(counts):
    if c > 0:
        cutt = prediction == i
        plt.figure()
        plt.imshow(spectra[cutt,:].T, aspect = 'auto', interpolation = 'nearest')
        plt.title(id.isotopes[i])

        plt.xlabel('Acquisition Index')
        plt.ylabel('Energy Bin Index')

        plt.savefig(
            os.path.join(paths['plot'], '%s__%s__2d_spectra.pdf' % (input_filename.replace('.h5', ''), id.isotopes[i])))
        plt.close()



# plt.figure(figsize = [20, 20])
# plt.plot(np.argmax(prob_array, axis = 1))
#
# plt.figure()
# plt.imshow(prob_array, aspect = 'auto', interpolation = 'nearest')
#
# plt.figure(figsize = [20, 20])
# plt.subplot(2, 2, 1)
# plt.imshow(snr_array.T, aspect = 'auto', interpolation = 'nearest')
# plt.title('SNR')
#
# plt.xlabel('Acquisition Index')
#
# plt.ylabel('SNR')
#
#
# plt.subplot(2, 2, 2)
# plt.imshow(prob_array.T, aspect = 'auto', interpolation = 'nearest')
# plt.title('Probability')
# plt.xlabel('Acquisition Index')
# plt.ylabel('Class Index')
#
# plt.subplot(2, 2, 3)
# plt.grid()
# for i in xrange(prob_array.shape[1]):
#     plt.plot(prob_array[:,i], alpha = 0.5, color = plotColors[i % 7], linestyle = lineStyles[i/7], label = '{}'.format(id.isotopes[i]))
# plt.legend(fontsize = 9)
# plt.xlabel('Acquisition Index')
# plt.ylabel('Probability')
#
# plt.title('Probability of each Class')
#
# plt.subplot(2, 2, 4)
# plt.grid()
# plt.plot(np.argmax(prob_array, axis =1), alpha = 0.5, label = 'Class Index')
# plt.plot(spectra.sum(1)/max(spectra.sum(1)), label = 'Counts (normalized)')
#
# plt.title('Index of Class with Highest Probability')
#
# plt.xlabel('Acquisition Index')
# plt.ylabel('Predicted Class Index')
# plt.legend()
#
#
# plt.figure()
# plt.grid()
# plt.imshow(spectra.T, aspect = 'auto', interpolation = 'nearest')
# plt.xlabel('Acquisition Index')
# plt.ylabel('Energy Bin')
# plt.title('Rebinned Spectra\n{}'.format(input_filename))

